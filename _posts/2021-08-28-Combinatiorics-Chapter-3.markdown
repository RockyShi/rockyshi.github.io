---
layout: post
title: "Combinatorics Chapter 3"
subtitle: "Reading notes and excercises of 'The combinatorics in programming'"
date: 2021-08-28
author: Rocky Shi
category: notes
tags: notes combinatorics
finished: false
---

## 笔记
### 3.1 基本概念

这部分属于高中程度,没有什么问题。

### 3.2 分拆与置换

这里的有些表示方法还没有完全吃透。

### 3.3 排列与组合的生成算法

这部分是竞赛的基础，滚瓜烂熟。一般来说有递归和循环生成两种，竞赛一般采用递归，因为可以顺便剪枝。

### 3.4 购票问题

- 算法3的f(m,0)=1让我困惑了一下，我原以为是m!。后来在草稿纸上列了一下，发现是我搞混了。在最终讨论的结果里，拿50元的人是没有区别的，如果以排列讨论，最终要除去n!，或者开始就以组合讨论。文中用组合讨论，所以答案是1,而我拐到了排列那边，得到了m!的答案。<p/>
- 算法5的理解还不完全。到二叉树的模型转换能理解，但对Catalan数不了解。查了[百度百科](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0)，大概有点懂了。
- Catalan数满足以下递推式
  - Cat(n+1) = Cat(0)Cat(n) + Cat(1)Cat(n-1) + ... + Cat(n)Cat(0)
  - (n-3)Cat(n) = n/2 `*` [Cat(3)Cat(n-1) + Cat(4)Cat(n-2) + ... + Cat(n-2)Cat(4) + Cat(n-1)Cat(3)]
- 而排列组合方法中，不符合特征的数如何与n+1个0和n-1个1一一对应起来。现在也明白了。将后半部分的0和1对调，是为了将m消去的同时不回到原来的n个0和n个1。

### 3.5 “方程的解”问题

- 如何得到C(p'+n-1,n-1)的过程能明白。
- 用质因数的方式只做高精度乘法的要点在于把前面公式从除法表示改写成连续整数的乘法。

## 书面练习

1. 证明C(n,m)是整数，m<=n

   > 这个直觉上不言而喻，具体如何证明却有点摸不着头脑。

2. 当n为多大时，n!超过pascal规定的长整型的上界。

   > 用C的long试了一下，13!的值已经不对了。  
   > 12!显示479001600, 而13!却显示1932053504，如果答案正确至少开头应该是5.

3. 证明C(n, r) = C(n, n-r)

   > C(n, r) = P(n, r)/r! = n!/(n-r)!/r!
   > C(n, n-r) = P(n, n-r)/(n-r)! = n!/(n-(n-r))!/(n-r)! = n!/r!/(n-r)!
   > 证明完毕

4. 1730年James Stirling给出了n!的近似公式sqrt(2* pi * n)*(n/e)^n

   (1) n=20时误差是多少  
   (2) 理论分析可得相对误差近似于1/(12 * n)，考虑这一相对误差后20!的误差是多少

    > 算起来不难，懒得算。想念我二十年前大学时代老旧破pc上的Mathematica 5.0 (话说现在最新版本已经到12.3了，这迭代速度一点都不线性啊！)

5. 能整除1400的正整数有多少个?

   >解： 1400=2^3^ `*` 5^2^ `*` 7,则从三个集合[1,2,4,8],[1,5,25]和[1,7]中各取一个数相乘，一定能被1400整除。根据乘法原理，答案是24。
    
6. n个完全一样的球，放到r个有标志的盒子中，且n>=r，要求无一空盒，有多少种方案？

   >解: 该题等价于将n个球放入一个大长盒子中，在球和球的间隙放入r-1个隔板，形成r个小盒子。由于一个间隙只能放一个隔板，所以没有空盒子。因此答案为C(n-1,r-1)
    
7. 凸十边形的任意三个对角线不共点，试求这凸十边形的对角线共交于多少个点？把所有的对角线分成多少段？

   >解： 凸十边形共有n*(n-3)/2=35条对角线。若任意三个对角线不共点，则有C(35,2)个交点。每条对角线与另外34条对角线都有交点，被34个交点分成35段。因此35条对角线共分成35*35段。
    
8. 一个凸N边形，通过不相交于N边形内部的对角线，把N边形拆分成若干三角形。请证明不同拆分的数目为Catalan数。
   >证明抄自百度百科:  
   >将凸多边形的顶点按顺时针顺序依次标记为P1,P2,...Pn，取任意一点Pk(1<k<n)和P1,Pn组成一个三角形，并将原来的凸多边形划分成2个凸多边形。
   >其中一个是P1,P2,...,Pk组成的凸k边形,另一个是Pk+1,Pk+2,...,Pn组成的凸n-k+1边形。  
   >则根据乘法原理，当Pk确定的时候,f(n)等于f(k)`*`f(n-k+1)，而根据加法原理，k从2变到n-1，所有的f(k)应当相加，由此得到的总方案数为  
   >f(n) = f(2)f(n-2+1) + f(3)f(n-3+1) + ... + f(n-1)f(2)，由此可知f(n) = Cat(n-2)

9. 设2n个点均匀地分布在一个圆的圆周上。能用n条不相交的弦把这些点两两配对。证明这种配对的方法数是第n个Catalan数。
   >仿上题的证明：  
   >将圆上的点按顺时针顺序依次标记为P1,P2,...P2n。取P1作一端，另一端选择Pk，则该弦将圆周分为两部分，一边有P2,P3,...Pk-1，另一边有Pk+1,Pk+2,P2n。  
   >则f(2n) = f(k-2)f(2n-k), 注意k的选择，如果k是单数的话，则会形成一边有奇数个点而不符合条件。所以1<k<=2n,k mod 2 == 0。  
   >则f(2n) = f(0)f(2n-2) + f(2)f(2n-4) + ... + f(2n-2)f(0)，设2n=t,则f(t) = f(0)f(t-1) + f(1)f(t-2) + ... + f(n-1)f(0) = Cat(t)  
   >得证

## 编程练习

10. 输入n(n<=2000)，输出n!的末尾的零的个数。

    >零的个数主要是考虑2和5,要对1到n进行因数分解，统计2和5的个数。一般来说2肯定比5多，所以统计5的个数就够了。  
    ```
    int count_zero(int n)
    {
      int count=0, factor = 5;
      while(factor <= n)
      {
        count += n/factor;
        factor *=5;
      }
      return count;
    }
    ```
11. 购票算法中的算法3可以修改为使用一个二维数组作为cache，如果cache里是-1，则f(m,n)是第一次计算，用递归继续，否则返回cache里的值。请分析修改后的时间复杂度。

    >实现很简单，略。

12. 若在购票问题中，m个人手持50,n个人手持100,则总方法数是多少？仿照书中实现并计算复杂度。

    >  
    > - 使用算法3或4，仍然可以方便的计算出来。
    > - 算法5还需要再想想。

13. 电子锁问题。
某机要部门安装了电子锁,要给M个工作人员（M<=7)每人发一张磁卡。卡上有一些密码特征，按规定至少有N个人(N<=4)同时使用各自的磁卡才能把锁打开。现在需要计算，电子锁上至少要有多少种特征，每个人的磁卡上至少要有多少个特征才能满足题设。要求电子锁总的特征数最少，特征编号以小写字母表示，将每个人的磁卡特征打印出来。例如M=3,N=2，则电子锁要用abc三个特征打开，三张磁卡分别是ab, bc和ac。

    > 设L(M,N)表示锁有几种特征，K(M,N)表示卡上有几种特征，则有  
    > N-1个人在一起就不能打开锁，说明至少缺少一种特征X，而剩下的任何一个人加入就能补上X，说明M-N+1个人共享一个特征X。  
    > 设一个N-1人组G缺少的特征为X(G)，则任意两个不同的G的X(G)各不相同。  
    > 证明： 由反证法，假设X(G1) = X(G2) = x，而G1并G2的集合显然大于N，但是这个N个人的组合都缺少x，从而与题设不符，得证。  
    > 因此总特征数需要大于等于C(M,N-1)。  
    > 对于任意一个人来说，他的卡上要有除他以外的所有N-1组缺少的特征，即C(M-1,N-1)。
    > 为求最优，L(M,N) = C(M,N-1), K(M,N) = C(M-1,N-1)。  
    > 具体分配的方法，可以采用遍历生成M个人中所有N-1的Group，为每个Group分配特征，然后将该特征分到每一个不在该Group中的人的卡上。  
    > 因为C(M,N) = C(M, M-N)，所以可以判断N-1和M-N+1谁比较小，就生成谁的组合。
    > 在《应用密码学》一书中，解释了这个是(m,n)门限方案,并在23.2节给出了密码学实现的方法。  

14. 铁轨问题。
某城市有一个火车站，有三条铁轨ABC，其中A和B分别和C相连。每列火车都由A进入火车站，经由C到达B，再驶出火车站。假设A有n节车厢，分别编号从1到n（n<=1000）,假设C可停放任意多节车厢，但车厢一旦进入C，就不能退回A;一旦进入B，就不能退回C。负责车厢调度的工作人员需要知道能否以某一个特定车厢序列A1,A2,A3,...,An从B驶出。

    >类似书中的进出栈问题，若i<j<k而Aj<Ak<Ai则不满足出栈队列可能。

15. 计数问题。  
以`<`将n个不同的对象排成一列，有n!种排法。如果以`<`或者`=`将n个不完全相同的对象排成一列，有多少种排法。  
例如n=2，有3种a=b,a<b,b<a；注意a=b和b=a是一样的。若n=3则有13种

    >设se(n)表示题设要求的排列数，将n个元素分为两组，一组只用`<`，一组只用`=`且至少有两个元素。存在`=`的组应整体视为一个元素和另一组的元素进行全排列。  
    对于2个元素而言，分组有2种：(0,2)和(2,0)。(0,2)即两个元素只用`=`，则只有一种a=b；(2,0)即两个元素只用`<`，则有两种a<b,b<a。即se(2)=3=1+2=C(2,2)+P(2,2)  
    对于3个元素而言，分组有3种：(0,3),(1,2)和(3,0)。(0,3)即三个元素全用`=`，只有一种a=b=c；(1,2)即两个元素用`=`，和另外1个元素全排列；(3,0)即全部元素用`<`，有3!种。即se(3)=13=1+6+6=C(3,3)+C(3,2)C(1,1)P(2,2)+P(3,3)   
    代码如下，设已有函数定义int Perm(int m, int n)和int Comb(int m, int n)来计算排列和组合的数目。  
    ```
    int count(int n)  
    {  
      int sum = Perm(n, n);
      for (int e = n; e > 0; e--)  
      {  
        if (e == 1) continue;  
        int g = n - e;
        sum += Comb(n, e) * Comb(g + 1, g + 1);  
      }  
      return sum;  
    }  
    ```
16. 走道铺砖问题。
一栋正在修建的大楼需要铺设多个走道。地板砖只有1`*`2一种规格，而业主不希望任意两个走道有重复的铺设方案。对一个N`*`M(N`*`M为偶数)的走道，用1`*`2的地砖铺满，有多少种方案？其中min(N,M)<=12，1<=N,M<=40且N*M为偶数。

## 一些说明和感想

## 更新日志
- Github Pages用的markdown语法和我VS插件的语法不一样，改了好多版都不太对。:(
- 20210907 查了一些书和网上的资料，更新一些题目的答案。
